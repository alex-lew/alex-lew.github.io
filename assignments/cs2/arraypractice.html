<!DOCTYPE html>

<html>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111705087-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111705087-1');
  </script>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A homework assignment from CS 2 at Commonwealth School. Use 2D arrays in Go to implement Conway's Game of Life.">
  <title>Conway's Game of Life</title>
  <link rel="stylesheet" type="text/css" href="/styles.css">
  <link href="https://fonts.googleapis.com/css?family=Nunito:400,700|Source+Code+Pro" rel="stylesheet">
  <link rel="stylesheet" href="/monokai.css">
  <link rel="stylesheet" href="/tango.css" media="print">
</head>
<body>

  <section id="post">
<div id="breadcrumbs"><a href="/index.html">alex lew</a><span class="breadcrumb-divider"></span><a href="/cs2.html">CS 2</a></div>
          <h1 id="blogtitle">Conway's Game of Life</h1>
          <div id="blogcontent"><div class="nobreak"><h3 class="assignment-heading keep-with-next">Assignment overview</h3><p>In this assignment, you’ll gain practice with arrays by implementing Conway’s Game of Life, a simplified model of the rise and fall of organisms or societies that leads to pretty patterns. (Check out the Wikipedia page!)</p></div><div class="nobreak"><h3 class="assignment-heading keep-with-next">Rules of the game</h3><p>In the Game of Life, you work with a grid of “cells,” each of which is “alive” or “dead.” You will represent this grid as an array of Booleans (alive is true, dead is false). You may choose whether you want to use a 1D array or a 2D array. If you use a 1D array, that is, a simple array of Booleans, you will think of index <code>i</code> as representing the <code>i</code><sup>th</sup> cell, counting from the top left, all the way across a row, then across the second row, then the third, and so on. If you use a 2D array, then index <code>[i][j]</code> can represent the <code>i</code><sup>th</sup> row and <code>j</code><sup>th</sup> column.</p></div><p>The grid is filled with an initial pattern of on-and-off cells. After this, the “game” procedes in generations, or time steps. Each generation, every cell in the grid updates itself simultaneously, according to the following rules (taken from Wikipedia):</p><ol><li><p>Any live cell with fewer than two live neighbors dies, as if caused by underpopulation.</p></li><li><p>Any live cell with two or three live neighbors lives on to the next generation.</p></li><li><p>Any live cell with more than three live neighbors dies, as if by overpopulation.</p></li><li><p>Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.</p></li></ol><p>The word “neighbors” here refers to the eight cells that surround the current cell. You may realize that some cells, namely the ones at the borders of the grid, do not have eight neighbors. You should think of the grid as “wrapping around” horizontally and vertically, so that for example if I am in the furthest left column, and walk one step left, I wrap around to the furthest right column.</p><p>You will implement a loop that clears the screen, prints the current generation’s grid to the Terminal, using symbols of your choice to represent live and dead cells (e.g. <code>*</code> and <code>.</code>), then uses the current generation to compute the next generation, and sleeps for a bit before looping back and continuing the animation.</p><div class="nobreak"><h3 class="assignment-heading keep-with-next">Instructions</h3><div class="nobreak"><h4 class="assignment-problem keep-with-next"><span class="problem-number">1</span><span class="problem-name">A type for the game of life</span></h4><p>Declare a <code>grid</code> type with whatever underlying type you’d like to use to represent the grid (likely an array of Booleans or an array of arrays of Booleans). The grid should be 50x50 in size, so altogether you will be storing 2,500 Booleans. (Note: if you’d like to use a different size, that’s all right! Anything much taller than 50 will be hard, because your Terminal window doesn’t get that tall; you might want to make it shorter or wider, though.) Implement the following useful methods on the type:</p></div></div><ul><li><p><code>AliveAt(row, column int) bool</code>, which returns true if the cell at the given row and column is alive, false otherwise.</p></li><li><p><code>SetValueAt(row int, column int, newValue bool)</code>, which has a <em>pointer receiver</em> (that is, declare it as <code>func (g *grid) SetValueAt(...)</code> instead of <code>func (g grid) SetValueAt(...)</code>), so that you can actually change the grid inside this method. This method just changes the current value of the cell at <code>(row, column)</code> to <code>newValue</code>.</p></li><li><p><code>Draw()</code>, which uses <code>Print</code> and <code>Println</code> statements to visualize the current grid, using characters of your choice for alive and dead cells.</p><p><code>NeighborsOf(row, column int) [8]bool</code>, which returns an array of eight booleans representing the eight neighbors of the given cell. Remember that we wrap around when we hit the edge. (That is, <code>(0, 0)</code> has as its neighbors <code>(49, 49), (0, 49), (1, 49), (49, 0), (1, 0), (49, 1), (0, 1), (1, 1)</code>.)</p></li><li><p><code>CountAliveNeighbors(row, column int) int</code>, which returns the number of alive neighbors of a given cell. This shouldn’t be too hard if you can use <code>NeighborsOf</code>.</p></li><li><p><code>AliveInNextGeneration(row, column int) bool</code>, which returns true if the given cell will be alive in the next generation. This should be easy if you already have <code>CountAliveNeighbors</code>.</p></li><li><p><code>NextGeneration() grid</code>, which returns a brand new grid in which every cell has been updated for the next generation.</p></li></ul><div class="nobreak"><h4 class="assignment-problem keep-with-next"><span class="problem-number">2</span><span class="problem-name">An initial state</span></h4><p>In your main function, create a new grid and set some of its entries to true. You may want to look at Wikipedia’s Game of Life page for some good ideas on initial configurations!</p></div><div class="nobreak"><h4 class="assignment-problem keep-with-next"><span class="problem-number">3</span><span class="problem-name">The main loop</span></h4><p>Now, loop infinitely (using <code>for {...}</code>), and in each iteration, do the following:</p></div><ol><li><p>Clear the screen, using <code>clear.WipeScreen()</code> from the package you used in your animations assignment.</p></li><li><p>Use the current grid’s <code>Draw</code> method to print it to the screen.</p></li><li><p>Compute the new grid: <code>currentGrid = currentGrid.NextGeneration()</code>.</p></li><li><p>Sleep for a small amount of time: <code>time.Sleep(300 * time.Millisecond)</code> is reasonable.</p></li></ol><p>Enjoy your animation! You can now experiment with different starting configurations if you’d like.</p></div>
  </section>
</body>