<!DOCTYPE html>

<html>
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111705087-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111705087-1');
  </script>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A homework assignment from AP CSP at Commonwealth School. Use Go's interfaces to create a program for animating shapes.">
  <title>Interfaces for animation</title>
  <link rel="stylesheet" type="text/css" href="/styles.css">
  <link href="https://fonts.googleapis.com/css?family=Nunito:400,700|Source+Code+Pro" rel="stylesheet">
  <link rel="stylesheet" href="/monokai.css">
  <link rel="stylesheet" href="/tango.css" media="print">
</head>
<body>

  <section id="post">
<div id="breadcrumbs"><a href="/index.html">alex lew</a><span class="breadcrumb-divider"></span><a href="/cs2.html">CS 2</a></div>
          <h1 id="blogtitle">Interfaces for animation</h1>
          <div id="blogcontent"><div class="nobreak"><h3 class="assignment-heading keep-with-next">Assignment overview</h3><p>In this assginment, you’ll create a more sophisticated animation system than in your previous assignment. You will use interfaces to allow the system to handle a variety of shapes and drawing mechanisms.</p></div><p>Here is a general overview of how your system will work:</p><ol><li><p>A <strong>scene</strong> consists of up to three <strong>shapes</strong>, all at different <strong>positions</strong>.</p></li><li><p><strong>shape</strong> is an interface, with a number of different concrete types representing different shapes. Each <strong>shape</strong> type has a method called <code>VisibleAtPoint</code> that given an x, y coordinate, returns a Boolean, indicating whether the shape must be drawn that point. It also contains a <strong>MoveTo</strong> method, which returns an updated version of the shape moved to a certain <code>(x, y)</code> position, and a <strong>GetPosition</strong> method, which returns its current position.</p></li><li><p>Each scene knows how to <code>Draw</code> itself. This involves looping through every coordinate, checking if any of its three shapes are visible at that point, and if so, printing a <code>#</code> symbol; if no shape is visible, a blank space is printed.</p></li><li><p>An <code>animation</code> is a type that has, as its underlying type, <code>func (int) scene</code>–a function that takes in a frame number and outputs a <code>scene</code>. It has a method to <code>Run</code> an animation from a certain frame to another frame, in a certain amount of time. This involves drawing a frame, sleeping for a bit, then clearing the screen and drawing another frame.</p></li></ol><div class="nobreak"><h3 class="assignment-heading keep-with-next">Install the clear package</h3><p>In Terminal, type <code>go get github.com/alex-lew/clear-screen-cs2</code>. This will allow you to <code>import clear "github.com/alex-lew/clear-screen-cs2"</code>, then call <code>clear.WipeScreen()</code> to clear the Terminal window between frames of animation.</p></div><div class="nobreak"><h3 class="assignment-heading keep-with-next">Step-by-step instructions</h3><div class="nobreak"><h4 class="assignment-problem keep-with-next"><span class="problem-number">1</span><span class="problem-name">Implement four shapes</span></h4><p>Declare an interface for shapes, with the methods <code>VisibleAtPoint</code> (accepting a <code>position</code> and returning a <code>bool</code>), <code>GetPosition</code> (returning a <code>position</code>, from your previous animation homework), and <code>MoveTo</code>, which takes a position as input and returns a new shape moved to that position.</p></div></div><p>Then design the following shape types, as structs:</p><ol><li><p><code>rectangle</code>, which represents a rectangle. Its position represents its top left corner; it also has a width and height. The rectangle struct should also have a boolean field, filled, which determines whether it is a <em>filled</em> rectangle, or just the outline of a rectangle. Its <code>VisibleAtPoint</code> method returns true if the given point lies on the border of the rectangle, or, if the rectangle is filled, inside the rectangle. The rectangle also has <code>GetPosition</code> and <code>MoveTo</code> methods, so that it is a valid shape.</p></li><li><p><code>circle</code>, which represents a circle. Its position represents its center. It also stores its radius. All circles are filled; no need to store a boolean for this. To implement the VisibleAtPoint method for a circle, just check the distance between the given point and the circle’s center; if this distance is less than or equal to the circle’s radius, return true. As above, the circle also must implement <code>GetPosition</code> and <code>MoveTo</code>.</p></li><li><p><code>groupedShape</code>, which represents two shapes grouped together into one, which move together. Use a struct with two fields holding “sub-shapes”. The <code>groupedShape</code> keeps track of a “core position,” and each sub-shape’s position is interpreted as being <em>relative</em> to the core position. If, for example, the <code>groupedShape</code> is located at (10, 4), and it contains sub-shapes located at (-7, -2) and (5, 6), the sub-shapes should actually be considered to be located at (3, 2) and (15, 10) respectively. The <code>MoveTo</code> and <code>GetPosition</code> methods of the <code>groupedShape</code> apply to the <em>core position</em>; by changing it, you automatically move both the sub-shapes together. To say whether the groupedShape is visible at a certain position, check whether <em>either</em> of its sub-shapes is visible at that position.</p></li><li><p>At least one shape of your own choosing / design. This can be something like the rectangle or circle (for instance, you could add a triangle shape), or it could be a “composite shape” type, like the groupedShape (you might add an <code>intersectionShape</code>, for instance, that is just like the groupedShape but instead of showing both subshapes, you show only their <em>intersection</em>; the shape is visible only at points where <em>both</em> subshapes overlap, i.e., where both are visible).</p></li></ol><div class="nobreak"><h4 class="extra-challenge keep-with-next">Extra Challenge: Outlined circle</h4><p>The <code>rectangle</code> type supports both filled and outlined variants, but the circle type described above is always filled. Modify it to support an “outline” option, by adding a <code>filled</code> boolean to your struct, and changing the <code>VisibleAtPoint</code> function accordingly.</p></div><div class="nobreak"><h4 class="assignment-problem keep-with-next"><span class="problem-number">2</span><span class="problem-name">The scene type</span></h4><p>Create a <code>scene</code> struct that stores up to three shapes. (If a shape is <code>nil</code>, that shape slot is unused.) It should have a <code>Draw</code> method, which assumes that the Terminal screen is an empty 80x24 grid (80 wide, 24 tall), and draws the scene. To do this, loop through each row and column, choosing whether to draw a space or a # character, based on whether any of your three shapes are visible. (At the end of each row, make sure to use <code>fmt.Println()</code> to move to the next row.)</p></div><div class="nobreak"><h4 class="assignment-problem keep-with-next"><span class="problem-number">3</span><span class="problem-name">The animation type</span></h4><p>Declare an <code>animation</code> type with underlying type <code>func (int) scene</code>. Give it a method, <code>(a animation) Run(from int, to int, duration time.Duration)</code>, which does the following:</p></div><ul><li><p>Based on whether <code>from &lt; to</code> or vice versa, determine whether this animation is running forward or backward.</p></li><li><p>Calculate how long each frame will take, if the entire animation is supposed to last for the given <code>duration</code>.</p></li><li><p>In a loop, run the animation. At the top of each loop, clear the screen using <code>clear.WipeScreen()</code>, then call the animation function with the current frame number to see what scene you should be drawing. Call the scene’s <code>Draw</code> method to draw it. Then <code>time.Sleep(•)</code> for the proper duration before the next iteration of the loop starts.</p></li></ul><div class="nobreak"><h4 class="assignment-problem keep-with-next"><span class="problem-number">4</span><span class="problem-name">Your own animation</span></h4><p>Create an animation with at least three shapes (not every shape needs to move). Your <code>main</code> function should run this animation from start to finish, and then from finish to start.</p></div></div>
  </section>
</body>